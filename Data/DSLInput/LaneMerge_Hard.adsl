// Scenario 2: Lane Merge (Hard)

SYSTEM LaneMerge_Hard {
    CPU {
        cores       = 1;
        scheduler   = LIMITED_PREEMPTIVE_FP;
        class_order = [ SafetyCritical > Chain > BestEffort ];
    }

    VEHICLE A { // Main lane vehicle ahead
        COMPONENT GapEvaluator_A {
            period   = 30ms;
            deadline = 35ms;
            WCET     = 10ms;
            class    = Chain;
            priority = 3;
        }
        COMPONENT MergeAckTx_A {
            WCET     = 3ms;
            deadline = 10ms;
            class    = Chain;
            priority = 4;
        }
    }

    VEHICLE C { // Main-lane follower to notify
        COMPONENT NotifyMerge_C {
            WCET     = 2ms;
            deadline = 10ms;
            class    = Chain;
            priority = 5;
        }
        COMPONENT Controller_C {
            WCET     = 10ms;
            deadline = 20ms;
            class    = BestEffort;
            priority = 10;
        }
    }

    VEHICLE B { // On-ramp vehicle
        COMPONENT Perception_B {
            period   = 30ms;
            deadline = 35ms;
            WCET     = 10ms;
            class    = BestEffort;
            priority = 8;
        }
        COMPONENT MergeReqTx_B {
            WCET     = 3ms;
            deadline = 10ms;
            class    = Chain;
            priority = 2;
        }
        COMPONENT MergeAckRx_B {
            WCET     = 3ms;
            deadline = 10ms;
            class    = Chain;
            priority = 6;
        }
        COMPONENT Planner_B {
            period   = 15ms;
            deadline = 20ms;
            WCET     = 12ms;
            class    = Chain;
            priority = 7;
        }
        COMPONENT Controller_B {
            WCET     = 22ms;
            deadline = 30ms;
            class    = Chain;
            priority = 9;
        }
    }

    CONNECT MergeRequest: B.MergeReqTx_B.output -> A.GapEvaluator_A.input    { latency_budget = 10ms; }
    CONNECT MergeAck:     A.MergeAckTx_A.output -> B.MergeAckRx_B.input      { latency_budget = 10ms; }
    CONNECT NotifyFollow: A.MergeAckTx_A.output -> C.NotifyMerge_C.input     { latency_budget = 10ms; }
    CONNECT PlanTrigger:  B.MergeAckRx_B.output -> B.Planner_B.input         { latency_budget = 4ms; }
    CONNECT CtrlTrigger:  B.Planner_B.output    -> B.Controller_B.input      { latency_budget = 90ms; }

    PROPERTY EndToEndLatency:
      "PIPELINE MergeReqTx_B
               -> GapEvaluator_A
               -> MergeAckRx_B
               -> Planner_B
               -> Controller_B
       WITHIN 180ms";

    OPTIMISATION {
        VARIABLES {
            A.GapEvaluator_A.period        range 20ms .. 50ms;
            B.Perception_B.period          range 20ms .. 50ms;
            B.Planner_B.period             range 10ms .. 30ms;

            A.GapEvaluator_A.WCET          range 6ms .. 15ms;
            A.MergeAckTx_A.WCET            range 1ms .. 5ms;
            C.NotifyMerge_C.WCET           range 1ms .. 4ms;
            C.Controller_C.WCET            range 8ms .. 15ms;
            B.MergeReqTx_B.WCET            range 1ms .. 5ms;
            B.MergeAckRx_B.WCET            range 1ms .. 5ms;
            B.Planner_B.WCET               range 8ms .. 18ms;
            B.Controller_B.WCET            range 15ms .. 28ms;

            MergeRequest.latency_budget    range 6ms .. 18ms;
            MergeAck.latency_budget        range 6ms .. 18ms;
            NotifyFollow.latency_budget    range 6ms .. 18ms;
            PlanTrigger.latency_budget     range 3ms .. 8ms;
            CtrlTrigger.latency_budget     range 70ms .. 120ms;
        }
        OBJECTIVES { minimise worst_end2end_latency; minimise max_core_utilisation; }
        CONSTRAINTS { assert EndToEndLatency; assert deadline_misses == 0; }
    }
}
