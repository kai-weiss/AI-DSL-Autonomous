// Scenario 1: Cooperative Overtaking (Hard)

SYSTEM Overtaking_Hard {
    CPU {
        cores       = 1;
        scheduler   = LIMITED_PREEMPTIVE_FP;
        class_order = [ SafetyCritical > Chain > BestEffort ];
    }

    VEHICLE A {
        COMPONENT Perception_A {
            period   = 40ms;
            deadline = 50ms;
            WCET     = 10ms;
            class    = BestEffort;
            priority = 5;
        }
        COMPONENT InteriorLight_A {
            period = 40ms;
            deadline = 60ms;
            WCET = 10ms;
            class = BestEffort;
            priority = 10;
        }

        COMPONENT AckHandler_A {
            // Triggered by an overtaking request message from Vehicle B
            WCET = 2ms;
            deadline = 15ms;
            priority = 2;
            class = Chain;
        }
    }

    VEHICLE B {
        COMPONENT Crash_B {
            deadline = 40ms;
            WCET = 10ms;
            class = SafetyCritical;
            priority = 1;

        }

        COMPONENT PermissionReqTx_B {
            // Triggered when Perception_B detects a "slower vehicle ahead"
            WCET = 2ms;
            deadline = 15ms;
            class = Chain;
            priority = 1;
        }
        COMPONENT PermissionAckRx_B {
            // Triggered by an Ack/Nack message from Vehicle A
            WCET = 2ms;
            deadline = 15ms;
            class = Chain;
            priority = 3;
        }
        COMPONENT TrajectoryPlanner_B {
            period = 10ms;
            deadline = 45ms;
            WCET = 10ms;
            class = Chain;
            priority = 4;
        }
        COMPONENT Controller_B {
            // Triggered when a new trajectory is available
            WCET = 25ms;
            deadline = 80ms;
            class = Chain;
            priority = 5;
        }
    }

    // V2V link from B to A for overtaking request (network latency budget)
    CONNECT OvertakeRequest: B.PermissionReqTx_B.output -> A.AckHandler_A.input { latency_budget = 8ms; }

    // V2V link from A back to B for permission acknowledgment (network latency budget)
    CONNECT PermissionAck: A.AckHandler_A.output -> B.PermissionAckRx_B.input { latency_budget = 8ms; }

    // Internal connections on vehicle B
    CONNECT PlanTrigger: B.PermissionAckRx_B.output -> B.TrajectoryPlanner_B.input { latency_budget = 3ms; }
    CONNECT ControllerTrigger: B.TrajectoryPlanner_B.output -> B.Controller_B.input { latency_budget = 80ms; }


    PROPERTY EndToEndLatency:
      "PIPELINE PermissionReqTx_B
               -> AckHandler_A
               -> PermissionAckRx_B
               -> TrajectoryPlanner_B
               -> Controller_B
       WITHIN 149ms";

    OPTIMISATION {
        VARIABLES {
            A.Perception_A.period          range 33ms .. 60ms;
            B.Perception_B.period          range 33ms .. 60ms;
            B.SafetyMonitor_B.period       range 15ms .. 30ms;
            B.TrajectoryPlanner_B.period   range 10ms .. 30ms;

            A.Perception_A.WCET            range 6ms .. 15ms;
            B.Perception_B.WCET            range 6ms .. 15ms;
            B.SafetyMonitor_B.WCET         range 3ms .. 8ms;
            B.PermissionReqTx_B.WCET       range 1ms .. 5ms;
            A.AckHandler_A.WCET            range 1ms .. 5ms;
            B.PermissionAckRx_B.WCET       range 1ms .. 5ms;
            B.TrajectoryPlanner_B.WCET     range 8ms .. 18ms;
            B.Controller_B.WCET            range 15ms .. 30ms;

            OvertakeRequest.latency_budget   range 4ms .. 16ms;
            PermissionAck.latency_budget     range 4ms .. 16ms;
            PlanTrigger.latency_budget       range 2ms .. 6ms;
            ControllerTrigger.latency_budget range 60ms .. 110ms;
        }
        OBJECTIVES { minimise worst_end2end_latency; minimise max_core_utilisation; }
        CONSTRAINTS { assert EndToEndLatency; assert deadline_misses == 0; }
    }
}
